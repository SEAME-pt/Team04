# Model Predictive Controller (MPC)

## Table of Contents

- [Introduction](#introduction)
- [Controller Architecture](#controller-architecture)
- [Mathematical Foundation](#mathematical-foundation)
- [Parameters](#parameters)
- [Tuning Guidelines](#tuning-guidelines)

## Introduction

Model Predictive Control is an advanced control technique that uses an internal model of the system to predict future states and optimize control inputs over a receding horizon.
 This makes it particularly well-suited for autonomous vehicle control where path planning and dynamic constraints play critical roles.

### Key Features

- **Lane Interpolation**: Interpolation of lane points for continuous boundary representation
- **Lane Following**: Robust tracking of lane boundaries with centerline calculation
- **Kinematic Model**: Bicycle kinematic model that captures essential vehicle dynamics
- **Constraint Handling**: Respects vehicle limits on steering angle and acceleration/deceleration
- **Predictive Control**: Anticipates future states to provide smoother and more accurate vehicle movement
- **Configurable Horizons**: Adjustable prediction and control horizons to balance computational load and performance
- **Tunable Optimization**: Weighted cost function components for customizing controller behavior

## Controller Architecture

### Overview of MPC Operation

1. **Lane Interpolation**: The controller converts discrete lane boundary points into continuous functions using interpolation techniques. This creates a smooth representation of the lane boundaries that can be evaluated at any position.

2. **Reference State Generation**: A reference trajectory is generated by calculating the centerline between the left and right lane boundaries. For each point along the prediction horizon, the controller determines the target position, heading, and velocity.

3. **State Prediction**: Using the vehicle's kinematic model, the controller predicts how the vehicle will move given different control inputs over the prediction horizon.

4. **Cost Function Formulation**: A comprehensive cost function is constructed that quantifies:
   - Path following error: Distance between predicted position and reference path
   - Heading alignment error: Difference between predicted heading and reference heading
   - Velocity tracking error: Difference between predicted velocity and target velocity
   - Control input smoothness: Penalizes large changes in acceleration and steering
   - Lane centering error: Distance from the vehicle to the center of the lane

5. **Optimization**: The controller uses numerical optimization (Sequential Least Squares Programming) to find the sequence of control inputs that minimizes the cost function while respecting constraints.

6. **Receding Horizon Application**: Only the first set of optimal control inputs is applied to the vehicle, then the entire process repeats at the next time step with updated information.

## Mathematical Foundation

### Kinematic Bicycle Model

The controller implements a kinematic bicycle model, which represents the vehicle as a simplified system with front and rear axles. This model provides a good balance between accuracy and computational efficiency.

The state update equations are:

```Python
x_next = x + velocity * cos(heading_angle) * dt
y_next = y + velocity * sin(heading_angle) * dt
heading_next = heading_angle + (velocity / wheelbase) * tan(steering_angle) * dt
v_next = max(0.0, velocity + acceleration * dt)
```

Where:

- `(x, y)` is the position of the rear axle center
- `heading_angle` is the orientation of the vehicle
- `velocity` is the longitudinal speed at the rear axle
- `wheelbase` is the distance between front and rear axles
- `steering_angle` is the angle of the front wheels relative to the vehicle's longitudinal axis
- `acceleration` is the longitudinal acceleration command
- `dt` is the time step

### Optimization Problem

The MPC formulates a constrained optimization problem:

minimize J(X, U) = Σ w₁·(path_error)² + w₂·(heading_error)² + w₃·(velocity_error)² +
                    w₄·(acceleration)² + w₅·(steering_angle)² + w₆·(lane_center_error)²

subject to:

- X₀ = current_state
- Xₖ₊₁ = f(Xₖ, Uₖ) for k = 0,...,N-1 (system dynamics)
- a_min ≤ acceleration ≤ a_max (acceleration constraints)
- -δ_max ≤ steering_angle ≤ δ_max (steering constraints)

Where:

- X = [x, y, heading, velocity] is the state vector
- U = [acceleration, steering_angle] is the control vector
- wᵢ are the weights for different components of the cost function
- f represents the kinematic bicycle model

#### Error Calculation

The controller calculates various errors to quantify performance:

- **Path error**: Euclidean distance between predicted and reference positions
- **Heading error**: Absolute difference between predicted and reference orientations
- **Velocity error**: Absolute difference between predicted and target speeds
- **Lane center error**: Distance from predicted position to lane centerline

#### Cost Function Weights

- `weight_path`: Weight for path following error (default: 1.0)
  - Higher values prioritize staying on the reference path
  - Dominant factor for accurate trajectory tracking
- `weight_heading`: Weight for heading error (default: 0.6)
  - Higher values keep the vehicle oriented along the path
  - Important for stable cornering and direction changes
- `weight_velocity`: Weight for velocity error (default: 0.1)
  - Higher values emphasize maintaining the target speed
  - Lower priority than position tracking in most scenarios
- `weight_acceleration_smoothness`: Weight for acceleration smoothness (default: 0.05)
  - Higher values produce gentler acceleration/deceleration
  - Improves passenger comfort and reduces mechanical stress
- `weight_steering_angle_smoothness`: Weight for steering smoothness (default: 0.1)
  - Higher values result in smoother steering inputs
  - Reduces oscillation and improves stability
- `weight_lane_center`: Weight for lane center error (default: 1.5)
  - Higher values prioritize keeping the vehicle centered in the lane
  - Most important factor for lane keeping functionality

#### Optimization Technique

The controller uses SciPy's SLSQP (Sequential Least Squares Programming) optimizer which:

- Handles nonlinear cost functions
- Supports bound constraints on variables
- Works efficiently for medium-sized problems
- Provides good convergence properties for trajectory optimization

## Parameters

### MPC Parameters

- `pred_horizon`: The number of time steps for prediction (default: 10)
  - Larger values provide more foresight but increase computational complexity
  - Typical range: 5-20 steps depending on processing power and required look-ahead distance
- `control_horizon`: The number of time steps for control optimization (default: 5)
  - Often smaller than prediction horizon to reduce computational load
  - Defines how many future control inputs are optimized at each step
- `dt`: Time step size in seconds (default: 0.1)
  - Affects the granularity of prediction and control
  - Smaller values provide more precise control but require more computational resources

### Vehicle Model Parameters

- `wheelbase`: Distance between front and rear axles (default: 0.1m)
  - Critical parameter for the bicycle model accuracy
  - Affects turning radius and vehicle dynamics
- `max_steering_angle`: Maximum allowed steering angle (default: 0.5 rad ≈ 30°)
  - Physical constraint of the steering system
- `max_acceleration`: Maximum allowed acceleration (default: 3.0 m/s²)
  - Upper limit for acceleration commands
- `max_deceleration`: Maximum allowed deceleration (default: -3.0 m/s²)
  - Lower limit for deceleration (braking)

## Tuning Guidelines

### Horizon Selection Guidelines

- **Short horizons** (5-8 steps):
  - More responsive to immediate changes
  - Lower computational demand
  - Better for high-speed or emergency situations
- **Long horizons** (12-20 steps):
  - Better anticipation of road curvature
  - Smoother overall behavior
  - More computationally intensive

### Weight Adjustment for Different Behaviors

The controller's behavior can be significantly influenced by adjusting the weights in the cost function:

- **Safety-focused configuration**:
  - Increase `weight_lane_center` and `weight_path` for strict lane keeping
  - Increase `weight_acceleration_smoothness` for gentler acceleration/braking

- **Performance-focused configuration**:
  - Increase `weight_velocity` for better speed tracking
  - Decrease smoothness weights for more aggressive control

- **Comfort-focused configuration**:
  - Increase both smoothness weights substantially
  - Slightly reduce `weight_path` to allow more gradual corrections

### Scenario-Specific Configurations

- **Urban driving**:
  - Shorter prediction horizon
  - Higher lane centering weight
  - Moderate smoothness weights
- **Highway driving**:
  - Longer prediction horizon
  - Higher velocity tracking weight
  - Higher steering smoothness weight
